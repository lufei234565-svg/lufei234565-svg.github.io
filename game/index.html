<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>ä»£ç æ¢é™©å²› Â· åŠ¨ä½œé—¯å…³ï¼ˆPhaserï¼‰</title>
<!-- Phaser 3.60 CDN -->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<style>
  html,body{height:100%;margin:0;background:#0f0f0f;color:#eee;font-family:"Microsoft YaHei",system-ui,Segoe UI,Roboto,sans-serif;}
  #game{width:100%;max-width:1100px;margin:0 auto;display:block;}
  .hud{
    position:fixed;left:50%;top:8px;transform:translateX(-50%);
    display:flex;gap:14px;align-items:center;background:#0008;
    border:1px solid #ffffff20;border-radius:12px;padding:8px 12px;backdrop-filter:blur(6px);z-index:10
  }
  .hud b{color:#ffd166}
  .top-right{
    position:fixed;right:12px;top:12px;display:flex;gap:10px;z-index:10
  }
  .btn{
    border:1px solid #ffffff22;background:#1f2937;color:#fff;border-radius:999px;padding:10px 14px;cursor:pointer;
  }
  .btn:hover{filter:brightness(1.1)}
  .modal{
    position:fixed;inset:0;background:#0009;display:none;align-items:center;justify-content:center;z-index:20
  }
  .card{
    background:#111; color:#fff; border:1px solid #333; border-radius:14px; padding:20px; width:min(500px,92vw); text-align:center;
    box-shadow:0 20px 60px #0008;
  }
  .card h2{margin:6px 0 10px;color:#22c55e}
  .row{display:flex;gap:12px;justify-content:center;margin-top:10px}
  /* ç§»åŠ¨ç«¯è™šæ‹ŸæŒ‰é”® */
  .pad{position:fixed;left:12px;bottom:12px;display:grid;grid-template-columns:repeat(3,56px);gap:10px;z-index:9;opacity:.85}
  .pad .pbtn{width:56px;height:56px;border-radius:50%;background:#1f2937;border:1px solid #ffffff22;color:#fff;font-size:18px}
  .pad .pbtn:active{filter:brightness(1.2)}
  .padR{position:fixed;right:12px;bottom:18px;display:flex;gap:10px;z-index:9}
  .padR .pbtn{width:72px;height:72px;border-radius:50%;background:#ef4444;border:1px solid #ffffff22;color:#fff;font-size:16px}
  @media (min-width:900px){ .pad,.padR{display:none} }
  footer{color:#9ca3af;text-align:center;padding:10px}
</style>
</head>
<body>

<div class="hud" id="hud">
  <span>å…³å¡ï¼š<b id="lvText">1 / 20</b></span>
  <span>HPï¼š<b id="hpText">100</b></span>
  <span>é‡‘å¸ï¼š<b id="coinText">0</b></span>
  <span>é’¥åŒ™ï¼š<b id="keyText">æ— </b></span>
</div>

<div class="top-right">
  <a class="btn" href="../">ğŸ  è¿”å›é¦–é¡µ</a>
  <button class="btn" id="resetBtn">ğŸ”„ é‡æ–°å¼€å§‹</button>
</div>

<!-- è™šæ‹Ÿæ‘‡æ† -->
<div class="pad" id="padL">
  <button class="pbtn" data-k="up">â–²</button>
  <div></div>
  <button class="pbtn" data-k="attack">âš”</button>
  <button class="pbtn" data-k="left">â—€</button>
  <button class="pbtn" data-k="down">â–¼</button>
  <button class="pbtn" data-k="right">â–¶</button>
</div>
<div class="padR" id="padR">
  <button class="pbtn" data-k="attack">æ”»å‡»</button>
</div>

<canvas id="game"></canvas>

<!-- é€šå…³/å¤±è´¥å¼¹çª— -->
<div class="modal" id="modal">
  <div class="card">
    <h2 id="modalTitle">é€šå…³ï¼</h2>
    <div id="modalBody">ä½ æ‰¾åˆ°äº†é’¥åŒ™å¹¶é€ƒå‡ºæ­¤åœ°</div>
    <div class="row" style="margin-top:6px">
      <button class="btn" id="btnRetry">é‡æ¥</button>
      <button class="btn" id="btnNext">ä¸‹ä¸€å…³</button>
    </div>
  </div>
</div>

<footer>Â© 2025 å¤§èƒ†ä¸“å±</footer>

<script>
/* ------------------ å‚æ•°/å·¥å…· ------------------ */
const TOTAL = 20;
const urlParams = new URLSearchParams(location.search);
const startLevel = Math.max(1, Math.min(TOTAL, +urlParams.get('level') || 1));

function saveProgress(n){
  const p = Math.max(+localStorage.getItem('passedLevels')||0, n);
  localStorage.setItem('passedLevels', Math.min(TOTAL, p));
}

function rnd(seed){ // ç®€å•å¯å¤ç°éšæœº
  let s = seed % 2147483647; if (s <= 0) s += 2147483646;
  return ()=> (s = s*16807 % 2147483647) / 2147483647;
}

/* ------------------ HUD/å¼¹çª— ------------------ */
const hpText = document.getElementById('hpText');
const coinText = document.getElementById('coinText');
const keyText = document.getElementById('keyText');
const lvText = document.getElementById('lvText');

const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modalTitle');
const modalBody  = document.getElementById('modalBody');
const btnRetry = document.getElementById('btnRetry');
const btnNext  = document.getElementById('btnNext');

document.getElementById('resetBtn').onclick = ()=>{
  if(confirm('ç¡®å®šæ¸…ç©ºé€šå…³è¿›åº¦å—ï¼Ÿ')){ localStorage.removeItem('passedLevels'); alert('å·²æ¸…ç©º'); }
};

/* ------------------ Phaser æ¸¸æˆ ------------------ */
const W = 1024, H = 576;

const config = {
  type: Phaser.CANVAS,
  canvas: document.getElementById('game'),
  backgroundColor: '#0b1015',
  scale: { width: W, height: H, mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
  physics: { default: 'arcade', arcade: { gravity: {y:0}, debug:false } },
  scene: { preload, create, update }
};

const game = new Phaser.Game(config);

let cursors, wasd, attackKey;
let player, enemies, coins, keyItem, door;
let hp=100, hasKey=false, coinCount=0, level=startLevel;
let attackHitbox;
let lastAttack=0;

function preload(){
  // ç”ŸæˆåŸºç¡€çº¹ç†ï¼ˆåœ†ã€çŸ©å½¢ã€æ˜Ÿæ˜Ÿï¼‰
  this.textures.generate('p', { data: createCircleData(24, '#00d1ff', '#89f1ff'), pixelWidth:1, pixelHeight:1 });
  this.textures.generate('e', { data: createCircleData(24, '#ff5252', '#ffc0c0'), pixelWidth:1 });
  this.textures.generate('coin', { data: createStarData(16, '#ffd166', '#fff0b3'), pixelWidth:1 });
  this.textures.generate('key', { data: createKeyData(), pixelWidth:1 });
  this.textures.generate('door', { data: createDoorData(), pixelWidth:1 });
  this.textures.generate('box', { data: createBoxData(), pixelWidth:1 });
  this.textures.generate('heal', { data: createCircleData(12, '#22c55e', '#bbf7d0'), pixelWidth:1 });
}

function create(){
  // èƒŒæ™¯ï¼ˆæ¸å˜+é›¾ï¼‰
  const g = this.add.graphics();
  g.fillGradientStyle(0x0a2530, 0x0a2530, 0x05141a, 0x05141a, 1);
  g.fillRect(0,0,W,H);
  g.fillStyle(0xffffff, 0.03); for(let i=0;i<60;i++){ g.fillCircle(Phaser.Math.Between(0,W), Phaser.Math.Between(0,H), Phaser.Math.Between(10,50)); }
  g.setDepth(-1);

  // å…³å¡æ–‡å­—
  this.title = this.add.text(W/2, 26, '', {fontSize:18, color:'#fff'}).setOrigin(.5,0);

  // åˆ›å»ºç‰©ç†ç»„
  this.walls = this.physics.add.staticGroup();
  enemies = this.physics.add.group();
  coins = this.physics.add.group();

  // ç©å®¶
  player = this.physics.add.sprite(100, H-100, 'p').setCircle(24).setBounce(0.1).setDrag(400).setMaxVelocity(240);
  player.setDepth(5);

  // æ”»å‡»åˆ¤å®š
  attackHitbox = this.add.rectangle(0,0,70,50,0xffffff,0).setDepth(6);
  this.physics.add.existing(attackHitbox);
  attackHitbox.body.enable = false;

  // é”®ç›˜
  cursors = this.input.keyboard.createCursorKeys();
  wasd = this.input.keyboard.addKeys({ up:'W', left:'A', down:'S', right:'D' });
  attackKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

  // ç¢°æ’
  this.physics.add.collider(player, this.walls);
  this.physics.add.collider(enemies, this.walls);
  this.physics.add.collider(enemies, enemies);

  this.physics.add.overlap(player, coins, (pl, c)=>{ c.destroy(); coinCount++; updateHUD(); }, null, this);
  this.physics.add.overlap(player, keyItem, ()=>{}, null, this);

  // è¿›å…¥å…³å¡
  buildLevel.call(this, level);

  // ä¸æ€ªç‰©æ¥è§¦æ‰è¡€
  this.physics.add.overlap(player, enemies, (pl, en)=>{
    if(this.time.now - lastAttack < 200) return; // æ”»å‡»ä¸­å…ä¼¤
    addHP(-8);
  });

  // æ‹¾å–é’¥åŒ™
  this.physics.add.overlap(player, keyItem, ()=>{
    if(!hasKey){ hasKey=true; keyItem.destroy(); keyItem=null; flashText(this, 'è·å¾—é’¥åŒ™ ğŸ”‘'); updateHUD(); }
  });

  // è§¦é—¨è¿‡å…³
  this.physics.add.overlap(player, door, ()=>{
    if(hasKey){
      // è¿‡å…³
      saveProgress(level);
      showModal(`ç¬¬ ${level} å…³é€šè¿‡ï¼`, `é‡‘å¸ ${coinCount}ï¼ŒHP ${hp}ã€‚ç»§ç»­æŒ‘æˆ˜ä¸‹ä¸€å…³ï¼Ÿ`);
    }
  });

  // è™šæ‹ŸæŒ‰é”®
  setupTouchControls(this);
}

function update(time, delta){
  if(!player.active) return;
  const speed = 220;
  let vx=0, vy=0;
  if(cursors.left.isDown || wasd.left.isDown || touch.left) vx -= speed;
  if(cursors.right.isDown|| wasd.right.isDown|| touch.right) vx += speed;
  if(cursors.up.isDown   || wasd.up.isDown   || touch.up) vy -= speed;
  if(cursors.down.isDown || wasd.down.isDown || touch.down) vy += speed;
  player.setVelocity(vx, vy);
  if(vx||vy){ player.rotation = Math.atan2(vy, vx); }

  // æ”»å‡»
  if(Phaser.Input.Keyboard.JustDown(attackKey) || touch.attack){
    doAttack(this);
  }

  // æ•Œäººç®€å• AI è¿½è¸ª
  enemies.children.iterate(e=>{
    if(!e) return;
    const ang = Phaser.Math.Angle.Between(e.x, e.y, player.x, player.y);
    const spd = Math.min(120, 60 + level*3);
    e.setVelocity(Math.cos(ang)*spd, Math.sin(ang)*spd);
  });
}

/* ------------------ å…³å¡ç”Ÿæˆ ------------------ */
function buildLevel(n){
  const seedRnd = rnd(1000+n*13);
  this.title.setText(`å…³å¡ ${n} / ${TOTAL}  â€”  ç›®æ ‡ï¼šæ‹¿é’¥åŒ™å¼€é—¨ï¼Œèº²é¿/å‡»è´¥æ€ªç‰©`);
  lvText.textContent = `${n} / ${TOTAL}`;

  // æ¸…åœº
  this.walls.clear(true,true); enemies.clear(true,true); coins.clear(true,true);
  if(keyItem) keyItem.destroy();
  if(door) door.destroy();
  hp = 100; hasKey=false; coinCount=0; updateHUD();

  // è¾¹ç•Œå¢™
  const margin=20;
  const wallRects = [
    [W/2, margin/2, W, margin], [W/2, H-margin/2, W, margin],
    [margin/2, H/2, margin, H], [W-margin/2, H/2, margin, H]
  ];
  // éšœç¢
  const blocks = 6 + Math.floor(n*0.6);
  for(let i=0;i<blocks;i++){
    const w = 140 + seedRnd()*120, h = 30 + seedRnd()*100;
    const x = 80 + seedRnd()*(W-160), y = 80 + seedRnd()*(H-160);
    wallRects.push([x,y,w,h]);
  }
  wallRects.forEach(([x,y,w,h])=>{
    const b = this.add.rectangle(x,y,w,h,0x1f2937,1);
    this.walls.add(b, true);
  });

  // æ”¾ç½®é—¨ & é’¥åŒ™ & ç©å®¶å‡ºç”Ÿ
  door = this.physics.add.staticSprite(W-70, 60, 'door').setDepth(2);
  keyItem = this.physics.add.staticSprite(80, 80, 'key').setDepth(2);
  player.setPosition(60, H-60);

  // é‡‘å¸
  const golds = 5 + Math.floor(n*0.5);
  for(let i=0;i<golds;i++){
    const cx = 50 + seedRnd()*(W-100), cy = 50 + seedRnd()*(H-100);
    if(Phaser.Geom.Intersects.RectangleToRectangle(new Phaser.Geom.Rectangle(cx-8,cy-8,16,16), door.getBounds())) continue;
    coins.add(this.physics.add.sprite(cx, cy, 'coin').setCircle(8));
  }

  // æ•Œäºº
  const enemyNum = 2 + Math.floor(n*0.8);
  for(let i=0;i<enemyNum;i++){
    const ex = 140 + seedRnd()*(W-280), ey = 120 + seedRnd()*(H-240);
    const e = enemies.create(ex, ey, 'e').setCircle(24).setBounce(0.8);
    e.setMaxVelocity(160);
  }
}

function addHP(d){
  hp = Math.max(0, Math.min(100, hp + d));
  updateHUD();
  blink(player, d<0 ? 0xff5252 : 0x22c55e);
  if(hp<=0){ showModal('å¤±è´¥äº† ğŸ’€', 'å†è¯•ä¸€æ¬¡å§ï¼', true); }
}

function updateHUD(){
  hpText.textContent = hp;
  coinText.textContent = coinCount;
  keyText.textContent = hasKey ? 'å·²è·å¾—' : 'æ— ';
}

/* ------------------ æˆ˜æ–— ------------------ */
function doAttack(scene){
  if(scene.time.now - lastAttack < 260) return;
  lastAttack = scene.time.now;

  const dir = new Phaser.Math.Vector2(Math.cos(player.rotation), Math.sin(player.rotation));
  attackHitbox.body.enable = true;
  attackHitbox.x = player.x + dir.x*38;
  attackHitbox.y = player.y + dir.y*38;
  scene.tweens.add({ targets: attackHitbox, alpha: .2, duration: 80, yoyo:true, onComplete: ()=>{ attackHitbox.body.enable=false; attackHitbox.alpha=0; } });

  // å‘½ä¸­æ£€æµ‹
  enemies.children.iterate(e=>{
    if(!e) return;
    if(Phaser.Geom.Intersects.RectangleToRectangle(attackHitbox.getBounds(), e.getBounds())){
      // æ‰“æ­»
      scene.add.tween({targets:e, scaleX:.6, scaleY:.6, duration:120, yoyo:false, onComplete:()=>e.destroy()});
      // æ‰é‡‘å¸
      const c = coins.create(e.x, e.y, 'coin').setCircle(8);
      c.setVelocity(Phaser.Math.Between(-70,70), Phaser.Math.Between(-70,70));
    }
  });
}

/* ------------------ UI / è§¦æ§ ------------------ */
function flashText(scene, text){
  const t = scene.add.text(W/2, H-40, text, {fontSize:20, color:'#fff'}).setOrigin(.5);
  scene.tweens.add({targets:t, y:H-80, alpha:0, duration:900, onComplete:()=>t.destroy()});
}
function blink(s, color){
  s.setTint(color); s.scene.time.delayedCall(120, ()=>s.clearTint());
}

function showModal(title, body, fail=false){
  modalTitle.textContent = title;
  modalTitle.style.color = fail ? '#ef4444' : '#22c55e';
  modalBody.textContent  = body;
  btnNext.style.display = fail ? 'none' : 'inline-block';
  modal.style.display = 'flex';
}

btnRetry.onclick = ()=>{
  modal.style.display = 'none';
  game.scene.scenes[0].scene.restart({}); // é‡æ–°åŠ è½½å½“å‰å…³
};
btnNext.onclick = ()=>{
  modal.style.display = 'none';
  level = Math.min(TOTAL, level+1);
  saveProgress(level);
  game.scene.scenes[0].scene.restart({});
};

/* ------------------ çº¹ç†ç”Ÿæˆï¼ˆåƒç´ æ•°æ®ï¼‰ ------------------ */
function createCircleData(r, color='#fff', glow='#fff'){
  const d = 2*r+2, data=[];
  for(let y=0;y<d;y++){
    let row = '';
    for(let x=0;x<d;x++){
      const dx=x-r-1, dy=y-r-1, dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<=r) row += color;
      else if(dist<=r+1) row += glow+'44';
      else row += '00';
      if(x<d-1) row+= ' ';
    }
    data.push(row);
  }
  return data;
}
function createStarData(r, color='#ffd166', glow='#fff0b3'){
  const d = 2*r+2, data=[];
  for(let y=0;y<d;y++){
    let row=''; for(let x=0;x<d;x++){
      const cx=r+1, cy=r+1;
      const ang=Math.atan2(y-cy,x-cx); const rad = r*(0.6+0.4*Math.sin(5*ang));
      const dist=Math.hypot(x-cx,y-cy);
      row += (dist<rad? color : (dist<rad+1?glow+'44':'00')) + (x<d-1?' ':'');
    } data.push(row);
  }
  return data;
}
function createKeyData(){
  const w=40,h=18, data=[];
  for(let y=0;y<h;y++){
    let row='';
    for(let x=0;x<w;x++){
      const on = (x<22 && y>4 && y<14) || // æŸ„
                 (x>=22 && x<36 && y>2 && y<16) || // å¤´
                 (x>=36 && y===8);
      row += on? '#ffd166' : '00';
      if(x<w-1) row+=' ';
    } data.push(row);
  } return data;
}
function createDoorData(){
  const w=40,h=60,data=[];
  for(let y=0;y<h;y++){
    let row=''; for(let x=0;x<w;x++){
      const on = x===0||x===w-1||y===0||y===h-1|| (x>3&&x<w-4&&y>3&&y<h-4);
      row += on? (y<6? '#facc15' : '#8b5e34') : '00';
      if(x<w-1) row+=' ';
    } data.push(row);
  } return data;
}
function createBoxData(){
  const w=80,h=20,data=[];
  for(let y=0;y<h;y++){
    let row=''; for(let x=0;x<w;x++){
      const edge = x===0||y===0||x===w-1||y===h-1; row += edge? '#4b5563' : '#1f2937';
      if(x<w-1) row+=' ';
    } data.push(row);
  } return data;
}

/* ------------------ è§¦å±æ§åˆ¶ ------------------ */
const touch = {up:false,down:false,left:false,right:false,attack:false};
function setupTouchControls(scene){
  const set=(k,v)=>{ touch[k]=v; if(v && (k==='attack')) doAttack(scene); };
  document.querySelectorAll('.pbtn').forEach(btn=>{
    const k = btn.dataset.k;
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); set(k,true); });
    btn.addEventListener('touchend',   e=>{ e.preventDefault(); set(k,false); });
    btn.addEventListener('mousedown',  e=>{ set(k,true); });
    btn.addEventListener('mouseup',    e=>{ set(k,false); });
    btn.addEventListener('mouseleave', e=>{ set(k,false); });
  });
}
</script>
</body>
</html>
